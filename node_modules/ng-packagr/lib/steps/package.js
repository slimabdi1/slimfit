"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const ng_package_data_1 = require("../model/ng-package-data");
const json_1 = require("../util/json");
const fs_extra_1 = require("fs-extra");
const lodash_1 = require("lodash");
const log = require("../util/log");
const PACKAGE_JSON_FILE_NAME = 'package.json';
// this prevents array objects from getting merged to each other one by one
function arrayMergeLogic(objValue, srcValue) {
    if (lodash_1.isArray(objValue)) {
        return objValue.concat(srcValue);
    }
}
// ensures paths are absolute by combining with working directory
function resolvePaths(workingDirectory, packageConfig) {
    if (packageConfig) {
        if (packageConfig.dest) {
            packageConfig.dest = path.resolve(workingDirectory, packageConfig.dest);
        }
        if (packageConfig.src) {
            packageConfig.src = path.resolve(workingDirectory, packageConfig.src);
        }
    }
}
;
function readNgPackageFile(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        log.debug('Searching for ng-package config at ' + filePath);
        try {
            const ngPkg = yield fs_extra_1.readJson(filePath);
            log.debug('Ng-package config found at ' + filePath);
            const basePath = path.dirname(filePath);
            resolvePaths(basePath, ngPkg);
            return ngPkg;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                log.debug('ng-package config file not found');
                // if the file does not exist, that's ok
                return null;
            }
            throw error;
        }
    });
}
function shouldExcludeFromDirectorySearch(searchDirectory, foldersToExclude) {
    for (const exclusionFolder of foldersToExclude) {
        if (exclusionFolder.endsWith(searchDirectory)) {
            return true;
        }
    }
    return false;
}
function getTopLevelFolderPaths(rootFolderPath, foldersToExclude) {
    return __awaiter(this, void 0, void 0, function* () {
        const directoriesToSearch = [];
        const fileSystemEntries = yield fs_extra_1.readdir(rootFolderPath);
        for (const fileSystemPath of fileSystemEntries) {
            const fullPath = path.resolve(rootFolderPath, fileSystemPath);
            const pathStats = yield fs_extra_1.lstat(fullPath);
            if (pathStats.isDirectory() && !shouldExcludeFromDirectorySearch(fileSystemPath, foldersToExclude)) {
                directoriesToSearch.push(fullPath);
            }
        }
        return directoriesToSearch;
    });
}
function findSecondaryPackagePaths(rootPackage) {
    return __awaiter(this, void 0, void 0, function* () {
        log.debug('Beginning package search from root ' + rootPackage.sourcePath);
        // Failing to exclude any of these folders will result in the wrong build output
        const foldersToExclude = [
            'node_modules',
            'dist',
            '.ng_build',
            ng_package_data_1.DEFAULT_BUILD_FOLDER,
            rootPackage.destinationPath
        ];
        const directoriesToSearch = yield getTopLevelFolderPaths(rootPackage.sourcePath, foldersToExclude);
        const packagePaths = [];
        // read all directories (without recursion)
        while (directoriesToSearch.length > 0) {
            const searchDirectory = directoriesToSearch.pop();
            const fileSystemEntries = yield fs_extra_1.readdir(searchDirectory);
            let packageFileFound = false;
            // file system entries might be files, or directories, or named pipes, etc.
            for (const fileSystemPath of fileSystemEntries) {
                const fullPath = path.resolve(searchDirectory, fileSystemPath);
                // discover the type of file system entry by using `lstat`.
                // NOTE: `lstat` is used instead of `stat` in order to prevent failures during resolution of symbolic links
                const pathStats = yield fs_extra_1.lstat(fullPath);
                if (pathStats.isDirectory() && !shouldExcludeFromDirectorySearch(fileSystemPath, foldersToExclude)) {
                    directoriesToSearch.push(fullPath);
                }
                else if (!packageFileFound && pathStats.isFile()) {
                    if (fileSystemPath.endsWith(PACKAGE_JSON_FILE_NAME)) {
                        packagePaths.push(fullPath);
                        packageFileFound = true;
                        // we can't `break` here because doing so might cause us to miss some directories
                    }
                }
            }
        }
        log.debug('Resolved secondary package paths: ' + packagePaths.join(','));
        return packagePaths;
    });
}
/**
 * Reads an Angular package definition first from the passed in file path,
 * then from the default ng-package.json file,
 * then from package.json, and merges the json into one config object.
 *
 * @param filePath path pointing to `ng-package.json` file
 */
function readRootPackage(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const cwd = process.cwd();
        if (!path.isAbsolute(filePath)) {
            filePath = path.resolve(cwd, filePath);
        }
        const baseDirectory = path.dirname(filePath);
        // read custom ng-package config file
        let promiseChain = readNgPackageFile(filePath)
            .then((ngPkg) => ngPkg || {});
        const defaultPath = path.join(baseDirectory, 'ng-package.json');
        if (defaultPath !== filePath) {
            // read default ng-package config file
            promiseChain = promiseChain.then((ngPkg) => __awaiter(this, void 0, void 0, function* () {
                const otherNgPkg = yield readNgPackageFile(defaultPath);
                // merge both ng-package config objects
                // merge will never return null
                return lodash_1.merge(ngPkg, otherNgPkg, arrayMergeLogic);
            }));
        }
        const ngPkg = yield promiseChain;
        // resolve paths relative to `ng-package.json` file
        const packageConfigurationDirectory = path.resolve(baseDirectory, ngPkg.src || '.');
        // read 'package.json'
        log.debug('loading package.json');
        const pkg = yield fs_extra_1.readJson(path.resolve(packageConfigurationDirectory, PACKAGE_JSON_FILE_NAME));
        // merge package.json ng-package config
        const finalPackageConfig = lodash_1.merge(ngPkg, pkg.ngPackage, arrayMergeLogic);
        // make sure we provide default values for src and dest
        finalPackageConfig.src = finalPackageConfig.src || packageConfigurationDirectory;
        finalPackageConfig.dest = finalPackageConfig.dest || path.resolve(packageConfigurationDirectory, 'dist');
        return new ng_package_data_1.NgPackageData(finalPackageConfig.src, pkg.name, finalPackageConfig.dest, finalPackageConfig.src, finalPackageConfig);
    });
}
function readSecondaryPackage(rootPackage, filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const baseDirectory = path.dirname(filePath);
        const ngPackageFile = path.resolve(baseDirectory, 'ng-package.json');
        const packageJsonFile = path.resolve(baseDirectory, PACKAGE_JSON_FILE_NAME);
        let ngPackage = yield readNgPackageFile(ngPackageFile);
        const packageJson = yield json_1.tryReadJson(packageJsonFile);
        // if we don't detect any explicit package configurations, then ignore
        if (!ngPackage) {
            if (!packageJson || !packageJson.ngPackage) {
                log.debug(`No secondary package found in ${baseDirectory}`);
                return null;
            }
        }
        ngPackage = lodash_1.merge(ngPackage, packageJson.ngPackage, arrayMergeLogic);
        if (!ngPackage.lib) {
            ngPackage.lib = {};
        }
        ngPackage.lib.externals = rootPackage.libExternals;
        return new ng_package_data_1.NgPackageData(rootPackage.sourcePath, rootPackage.fullPackageName, rootPackage.destinationPath, baseDirectory, ngPackage);
    });
}
/**
 * Search for, and read, root and secondary packages starting from a root path.
 *
 * @param {string} rootPath The path to your root folder which contains a package.json file
 * @returns {Promise<PackageSearchResult>}
 */
function discoverPackages(rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        // the root package gets read a bit differently than secondary packages because it must guarantee full paths
        const rootPackage = yield readRootPackage(rootPath);
        // With the metadata from the root package, we can proceed to read secondary packages in sub folders
        // This assumes that all secondary packages exist in sub paths of the root path.
        // Without such an assumption, automatic secondary package discovery would not be feasible.
        // Specifically, the function is looking for `ng-package.json` or `package.json` files.
        const secondaryPackagePaths = yield findSecondaryPackagePaths(rootPackage);
        const secondaryPackagePromises = secondaryPackagePaths
            .map(secondaryPackagePath => readSecondaryPackage(rootPackage, secondaryPackagePath));
        const secondaryPackagesFromPaths = yield Promise.all(secondaryPackagePromises);
        // The packages that are null should be excluded because they were not explicitly meant to be secondary entries
        const secondaryPackages = secondaryPackagesFromPaths.filter(x => !!x);
        return {
            rootPackage,
            secondaryPackages
        };
    });
}
exports.discoverPackages = discoverPackages;
/**
 * Creates a `package.json` file by reading one from the `src` folder, adding additional
 * properties, and writing to `dest` folder
 *
 * @param ngPkg Angular package data
 * @param packageArtifacts Package artifacts to merge into package.json
 */
function writePackage(ngPkg, packageArtifacts) {
    return __awaiter(this, void 0, void 0, function* () {
        log.debug('writePackage');
        const packageJson = yield fs_extra_1.readJson(path.resolve(ngPkg.sourcePath, PACKAGE_JSON_FILE_NAME));
        // set additional properties
        for (const fieldName in packageArtifacts) {
            packageJson[fieldName] = packageArtifacts[fieldName];
        }
        packageJson.name = ngPkg.fullPackageName;
        // keep the dist package.json clean
        // this will not throw if ngPackage field does not exist
        delete packageJson.ngPackage;
        yield fs_extra_1.writeJson(path.resolve(ngPkg.destinationPath, PACKAGE_JSON_FILE_NAME), packageJson);
    });
}
exports.writePackage = writePackage;
//# sourceMappingURL=package.js.map