"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vfs = require("vinyl-fs");
const path = require("path");
const log_1 = require("../util/log");
const fs_extra_1 = require("fs-extra");
// Angular Inliner for Templates and Stylesheets
const inlineNg2Template = require("gulp-inline-ng2-template");
// CSS Tools
const autoprefixer = require("autoprefixer");
const browserslist = require("browserslist");
const postcss = require("postcss");
const sass = require("node-sass");
const less = require("less");
const stylus = require("stylus");
/**
 * Process Angular components assets (HTML and Stylesheets).
 *
 * Inlines 'templateUrl' and 'styleUrl', compiles .scss to .css, and write .ts files to
 * destination directory.
 *
 * @param src Source folder
 * @param dest Destination folder
 */
exports.processAssets = (src, dest) => {
    return new Promise((resolve, reject) => {
        log_1.debug(`processAssets ${src} to ${dest}`);
        vfs.src([`${src}/**/*.ts`, `${src}/**/*.tsx`, `${src}/**/*.jsx`, '!node_modules/**/*', '!${dest}/**/*'])
            .pipe(inlineNg2Template({
            base: `${src}`,
            useRelativePaths: true,
            styleProcessor: (path, ext, file, cb) => __awaiter(this, void 0, void 0, function* () {
                log_1.debug(`render stylesheet ${path}`);
                const renderPickTask = pickRenderer(path, file, src);
                log_1.debug(`postcss with autoprefixer for ${path}`);
                const browsers = browserslist(undefined, { path });
                try {
                    const css = yield renderPickTask;
                    const result = yield postcss([autoprefixer({ browsers })])
                        .process(css, { from: path, to: path.replace(ext, '.css') });
                    result.warnings().forEach((msg) => {
                        log_1.warn(msg.toString());
                    });
                    cb(undefined, result.css);
                }
                catch (err) {
                    cb(err || new Error(`Cannot inline stylesheet ${path}`));
                }
            })
        }))
            .on('error', reject)
            .pipe(vfs.dest(`${dest}`))
            .on('end', resolve);
    });
};
const sassImporter = (url) => {
    if (url[0] === '~') {
        url = path.resolve('node_modules', url.substr(1));
    }
    return { file: url };
};
function pickRenderer(filePath, file, srcPath) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (path.extname(filePath)) {
            case '.scss':
            case '.sass':
                log_1.debug(`rendering sass for ${filePath}`);
                return yield renderSass({ file: filePath, importer: sassImporter });
            case '.less':
                log_1.debug(`rendering less for ${filePath}`);
                return yield renderLess({ filename: filePath });
            case '.styl':
            case '.stylus':
                log_1.debug(`rendering styl for ${filePath}`);
                return yield renderStylus({ filename: filePath, root: srcPath });
            case '.css':
            default:
                return file;
        }
    });
}
const renderSass = (sassOpts) => {
    return new Promise((resolve, reject) => {
        sass.render(sassOpts, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result.css.toString());
            }
        });
    });
};
const renderLess = (lessOpts) => {
    return fs_extra_1.readFile(lessOpts.filename)
        .then(buffer => buffer.toString())
        .then((lessData) => new Promise((resolve, reject) => {
        less.render(lessData || '', lessOpts, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result.css.toString());
            }
        });
    }));
};
/**
 * filename - absolute path to file
 * root - root folder of project (where ng-package.json is located)
 */
const renderStylus = ({ filename, root }) => {
    return fs_extra_1.readFile(filename)
        .then(buffer => buffer.toString())
        .then((stylusData) => new Promise((resolve, reject) => {
        stylus(stylusData)
            .include(root)
            .include('.')
            .include('node_modules')
            .set('filename', filename)
            .set('resolve url', true)
            .define('url', stylus.resolver())
            .render((err, css) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(css);
            }
        });
    }));
};
//# sourceMappingURL=assets.js.map