"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const __rollup = require("rollup");
const nodeResolve = require("rollup-plugin-node-resolve");
const commonJs = require("rollup-plugin-commonjs");
const log_1 = require("../util/log");
const rollup_globals_1 = require("../conf/rollup.globals");
/**
 * Runs rollup over the given entry file, bundling it up.
 *
 * @param opts
 */
function rollup(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const globals = Object.assign({}, rollup_globals_1.ROLLUP_GLOBALS, opts.externals);
        let bundleOptions = {
            context: 'this',
            external: Object.keys(globals),
            input: opts.entry,
            plugins: [
                nodeResolve({ jsnext: true, module: true }),
                commonJs(),
            ],
            onwarn: (warning) => {
                if (warning.code === 'THIS_IS_UNDEFINED') {
                    return;
                }
                console.warn(warning.message);
            }
        };
        const writeOptions = {
            // Keep the moduleId empty because we don't want to force developers to a specific moduleId.
            moduleId: '',
            name: `${opts.moduleName}`,
            file: opts.dest,
            format: opts.format,
            banner: '',
            globals: globals,
            sourcemap: true
        };
        log_1.debug(`rollup ${opts.entry} to ${opts.dest} (${opts.format})`);
        const bundle = yield __rollup.rollup(bundleOptions);
        yield bundle.write(writeOptions);
    });
}
exports.rollup = rollup;
//# sourceMappingURL=rollup.js.map