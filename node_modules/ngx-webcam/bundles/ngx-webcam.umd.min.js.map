{"version":3,"file":"ngx-webcam.umd.min.js","sources":["~/ngx-webcam/src/app/modules/webcam/domain/webcam-image.ts","~/ngx-webcam/src/app/modules/webcam/util/webcam.util.ts","~/ngx-webcam/src/app/modules/webcam/webcam/webcam.component.ts","~/ngx-webcam/src/app/modules/webcam/webcam.module.ts","~/ngx-webcam/src/app/modules/webcam/domain/webcam-init-error.ts","~/ngx-webcam/src/app/modules/webcam/domain/webcam-mirror-properties.ts"],"sourcesContent":["\n/**\n * Container class for a captured webcam image\n * @author basst314\n */\nexport class WebcamImage {\nprivate _mimeType: string = null;\nprivate _imageAsBase64: string = null;\nprivate _imageAsDataUrl: string = null;\n/**\n * @param {?} imageAsDataUrl\n * @param {?} mimeType\n */\npublic constructor(imageAsDataUrl: string, mimeType: string) {\n    this._mimeType = mimeType;\n    this._imageAsDataUrl = imageAsDataUrl;\n  }\n/**\n * Get the base64 encoded image data\n * @return {?}\n */\npublic get imageAsBase64(): string {\n    return this._imageAsBase64 ?\n      this._imageAsBase64 : this._imageAsBase64 = this.getDataFromDataUrl(this._imageAsDataUrl);\n  }\n/**\n * Get the encoded image as dataUrl\n * @return {?}\n */\npublic get imageAsDataUrl(): string {\n    return this._imageAsDataUrl;\n  }\n/**\n * Extracts the Base64 data out of the given dataUrl.\n * @param {?} dataUrl\n * @return {?}\n */\nprivate getDataFromDataUrl(dataUrl: string) {\n    return dataUrl.replace(\"data:\" + this._mimeType + \";base64,\", \"\");\n  }\n}\n\nfunction WebcamImage_tsickle_Closure_declarations() {\n/** @type {?} */\nWebcamImage.prototype._mimeType;\n/** @type {?} */\nWebcamImage.prototype._imageAsBase64;\n/** @type {?} */\nWebcamImage.prototype._imageAsDataUrl;\n}\n\n","\nexport class WebcamUtil {\n/**\n * Lists available videoInput devices\n * @return {?}\n */\npublic static getAvailableVideoInputs(): Promise<MediaDeviceInfo[]> {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n      return Promise.reject(\"enumerateDevices() not supported.\");\n    }\n\n    return new Promise((resolve, reject) => {\n      navigator.mediaDevices.enumerateDevices()\n        .then((devices: MediaDeviceInfo[]) => {\n          resolve(devices.filter((device: MediaDeviceInfo) => device.kind === 'videoinput'));\n        })\n        .catch(err => {\n          reject(err.message || err);\n        });\n    });\n  }\n}\n","import {AfterViewInit, Component, EventEmitter, Input, OnDestroy, Output, ViewChild} from '@angular/core';\nimport {WebcamInitError} from '../domain/webcam-init-error';\nimport {WebcamImage} from '../domain/webcam-image';\nimport {Observable, Subscription} from 'rxjs';\nimport {WebcamUtil} from '../util/webcam.util';\nimport {WebcamMirrorProperties} from '../domain/webcam-mirror-properties';\nexport class WebcamComponent implements AfterViewInit, OnDestroy {\nprivate static DEFAULT_VIDEO_OPTIONS: MediaTrackConstraints = {facingMode: 'environment'};\n/**\n * Defines the max width of the webcam area in px\n */\npublic width: number = 640;\n/**\n * Defines the max height of the webcam area in px\n */\npublic height: number = 480;\n/**\n * If the Observable represented by this subscription emits, an image will be captured and emitted through\n * the 'imageCapture' EventEmitter\n */\nprivate triggerSubscription: Subscription;\n/**\n * Defines base constraints to apply when requesting video track from UserMedia\n */\npublic videoOptions: MediaTrackConstraints = WebcamComponent.DEFAULT_VIDEO_OPTIONS;\n/**\n * Flag to enable/disable camera switch. If enabled, a switch icon will be displayed if multiple cameras were found\n */\npublic allowCameraSwitch: boolean = true;\n/**\n * Parameter to control image mirroring (i.e. for user-facing camera). [\"auto\", \"always\", \"never\"]\n */\npublic mirrorImage: string | WebcamMirrorProperties;\n/**\n * Subscription to switchCamera events\n */\nprivate switchCameraSubscription: Subscription;\n/**\n * MediaStream object in use for streaming UserMedia data\n */\nprivate mediaStream: MediaStream = null;\n/**\n * available video devices\n */\npublic availableVideoInputs: MediaDeviceInfo[] = [];\n/**\n * Index of active video in availableVideoInputs\n */\nprivate activeVideoInputIndex: number = -1;\n/**\n * Indicates whether the video device is ready to be switched\n */\npublic videoInitialized: boolean = false;\n/**\n * EventEmitter which fires when an image has been captured\n */\npublic imageCapture: EventEmitter<WebcamImage> = new EventEmitter<WebcamImage>();\n/**\n * Emits a mediaError if webcam cannot be initialized (e.g. missing user permissions)\n */\npublic initError: EventEmitter<WebcamInitError> = new EventEmitter<WebcamInitError>();\n/**\n * Emits when the webcam video was clicked\n */\npublic imageClick: EventEmitter<void> = new EventEmitter<void>();\n/**\n * Emits the active deviceId after the active video device was switched\n */\npublic cameraSwitched: EventEmitter<string> = new EventEmitter<string>();\nprivate video: any;\nprivate canvas: any;\nprivate activeVideoSettings: MediaTrackSettings = null;\n/**\n * @return {?}\n */\npublic ngAfterViewInit(): void {\n    this.detectAvailableDevices()\n      .then((devices: MediaDeviceInfo[]) => {\n        // start first device\n        this.switchToVideoInput(devices.length > 0 ? devices[0].deviceId : null);\n      })\n      .catch((err: string) => {\n        this.initError.next( /** @type {?} */((<WebcamInitError>{message: err})));\n        // fallback: still try to load webcam, even if device enumeration failed\n        this.switchToVideoInput(null);\n      });\n  }\n/**\n * @return {?}\n */\npublic ngOnDestroy(): void {\n    this.stopMediaTracks();\n    this.unsubscribeFromSubscriptions();\n  }\n/**\n * If the given Observable emits, an image will be captured and emitted through 'imageCapture' EventEmitter\n * @param {?} trigger\n * @return {?}\n */\npublic set trigger(trigger: Observable<void>) {\n    if (this.triggerSubscription) {\n      this.triggerSubscription.unsubscribe();\n    }\n\n    // Subscribe to events from this Observable to take snapshots\n    this.triggerSubscription = trigger.subscribe(() => {\n      this.takeSnapshot();\n    });\n  }\n/**\n * @param {?} switchCamera\n * @return {?}\n */\npublic set switchCamera(switchCamera: Observable<boolean | string>) {\n    if (this.switchCameraSubscription) {\n      this.switchCameraSubscription.unsubscribe();\n    }\n\n    // Subscribe to events from this Observable to switch video device\n    this.switchCameraSubscription = switchCamera.subscribe((value: boolean | string) => {\n      if (typeof value === 'string') {\n        // deviceId was specified\n        this.switchToVideoInput(value);\n      } else {\n        // direction was specified\n        this.rotateVideoInput(value !== false);\n      }\n    })\n  }\n/**\n * Get MediaTrackConstraints to request streaming the given device\n * @param {?} deviceId\n * @param {?} baseMediaTrackConstraints base constraints to merge deviceId-constraint into\n * @return {?}\n */\nprivate static getMediaConstraintsForDevice(deviceId: string, baseMediaTrackConstraints: MediaTrackConstraints): MediaTrackConstraints {\n    let /** @type {?} */ result: MediaTrackConstraints = baseMediaTrackConstraints ? baseMediaTrackConstraints : this.DEFAULT_VIDEO_OPTIONS;\n    if (deviceId) {\n      result.deviceId = {exact: deviceId};\n    }\n\n    return result;\n  }\n/**\n * Tries to harvest the deviceId from the given mediaStreamTrack object.\n * Browsers populate this object differently; this method tries some different approaches\n * to read the id.\n * @param {?} mediaStreamTrack\n * @return {?}\n */\nprivate static getDeviceIdFromMediaStreamTrack(mediaStreamTrack: MediaStreamTrack): string {\n    if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().deviceId) {\n      return mediaStreamTrack.getSettings().deviceId;\n    } else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().deviceId) {\n      let /** @type {?} */ deviceIdObj: ConstrainDOMString = mediaStreamTrack.getConstraints().deviceId;\n      return WebcamComponent.getValueFromConstrainDOMString(deviceIdObj);\n    }\n  }\n/**\n * Tries to harvest the facingMode from the given mediaStreamTrack object.\n * Browsers populate this object differently; this method tries some different approaches\n * to read the value.\n * @param {?} mediaStreamTrack\n * @return {?}\n */\nprivate static getFacingModeFromMediaStreamTrack(mediaStreamTrack: MediaStreamTrack): string {\n    if (mediaStreamTrack) {\n      if (mediaStreamTrack.getSettings && mediaStreamTrack.getSettings() && mediaStreamTrack.getSettings().facingMode) {\n        return mediaStreamTrack.getSettings().facingMode;\n      } else if (mediaStreamTrack.getConstraints && mediaStreamTrack.getConstraints() && mediaStreamTrack.getConstraints().facingMode) {\n        let /** @type {?} */ facingModeConstraint: ConstrainDOMString = mediaStreamTrack.getConstraints().facingMode;\n        return WebcamComponent.getValueFromConstrainDOMString(facingModeConstraint);\n      }\n    }\n  }\n/**\n * Determines whether the given mediaStreamTrack claims itself as user facing\n * @param {?} mediaStreamTrack\n * @return {?}\n */\nprivate static isUserFacing(mediaStreamTrack: MediaStreamTrack): boolean {\n    let /** @type {?} */ facingMode: string = WebcamComponent.getFacingModeFromMediaStreamTrack(mediaStreamTrack);\n    return facingMode ? \"user\" === facingMode.toLowerCase() : false;\n  }\n/**\n * Extracts the value from the given ConstrainDOMString\n * @param {?} constrainDOMString\n * @return {?}\n */\nprivate static getValueFromConstrainDOMString(constrainDOMString: ConstrainDOMString): string {\n    if (constrainDOMString) {\n      if (constrainDOMString instanceof String) {\n        return String(constrainDOMString);\n      } else if (Array.isArray(constrainDOMString) && Array(constrainDOMString).length > 0) {\n        return String(constrainDOMString[0]);\n      } else if (typeof constrainDOMString === \"object\") {\n        if (constrainDOMString[\"exact\"]) {\n          return String(constrainDOMString[\"exact\"]);\n        } else if (constrainDOMString[\"ideal\"]) {\n          return String(constrainDOMString[\"ideal\"]);\n        }\n      }\n    }\n\n    return null;\n  }\n/**\n * Takes a snapshot of the current webcam's view and emits the image as an event\n * @return {?}\n */\npublic takeSnapshot(): void {\n    // set canvas size to actual video size\n    let /** @type {?} */ _video = this.video.nativeElement;\n    let /** @type {?} */ dimensions = {width: this.width, height: this.height};\n    if (_video.videoWidth) {\n      dimensions.width = _video.videoWidth;\n      dimensions.height = _video.videoHeight;\n    }\n\n    let /** @type {?} */ _canvas = this.canvas.nativeElement;\n    _canvas.width = dimensions.width;\n    _canvas.height = dimensions.height;\n\n    // paint snapshot image to canvas\n    _canvas.getContext('2d').drawImage(this.video.nativeElement, 0, 0);\n\n    // read canvas content as image\n    // TODO allow mimeType options as Input()\n    let /** @type {?} */ mimeType: string = \"image/jpeg\";\n    let /** @type {?} */ dataUrl: string = _canvas.toDataURL(mimeType);\n\n    this.imageCapture.next(new WebcamImage(dataUrl, mimeType));\n  }\n/**\n * Switches to the next/previous video device\n * @param {?} forward\n * @return {?}\n */\npublic rotateVideoInput(forward: boolean) {\n    if (this.availableVideoInputs && this.availableVideoInputs.length > 1) {\n      let /** @type {?} */ increment: number = forward ? 1 : (this.availableVideoInputs.length - 1);\n      this.switchToVideoInput(this.availableVideoInputs[(this.activeVideoInputIndex + increment) % this.availableVideoInputs.length].deviceId)\n    }\n  }\n/**\n * Switches the camera-view to the specified video device\n * @param {?} deviceId\n * @return {?}\n */\npublic switchToVideoInput(deviceId: string): void {\n    this.videoInitialized = false;\n    this.stopMediaTracks();\n    this.initWebcam(deviceId, this.videoOptions);\n  }\n/**\n * @return {?}\n */\npublic get videoWidth() {\n    let /** @type {?} */ videoRatio = this.getVideoAspectRatio(this.activeVideoSettings);\n    return Math.min(this.width, this.height * videoRatio);\n  }\n/**\n * @return {?}\n */\npublic get videoHeight() {\n    let /** @type {?} */ videoRatio = this.getVideoAspectRatio(this.activeVideoSettings);\n    return Math.min(this.height, this.width / videoRatio);\n  }\n/**\n * @return {?}\n */\npublic get videoStyleClasses() {\n    let /** @type {?} */ classes: string = \"\";\n\n    if (this.isMirrorImage()) {\n      classes += \"mirrored \";\n    }\n\n    return classes.trim();\n  }\n/**\n * Return the video aspect ratio from the given mediaTrackSettings, if possible;\n * Otherwise, calculate given the width/height parameters only\n * @param {?} mediaTrackSettings\n * @return {?}\n */\nprivate getVideoAspectRatio(mediaTrackSettings: MediaTrackSettings): number {\n    if (mediaTrackSettings) {\n      if (mediaTrackSettings.aspectRatio) {\n        // if ratio is present - use it\n        return mediaTrackSettings.aspectRatio;\n\n      } else if (mediaTrackSettings.width && mediaTrackSettings.width > 0 &&\n        mediaTrackSettings.height && mediaTrackSettings.height > 0) {\n        // if width+height are present - calculate ratio\n        return mediaTrackSettings.width / mediaTrackSettings.height;\n      }\n    }\n\n    // nothing present in mediaTrackSettings - calculate ratio based on width/height params\n    return this.width / this.height;\n  }\n/**\n * Init webcam live view\n * @param {?} deviceId\n * @param {?} userVideoTrackConstraints\n * @return {?}\n */\nprivate initWebcam(deviceId: string, userVideoTrackConstraints: MediaTrackConstraints) {\n    let /** @type {?} */ _video = this.video.nativeElement;\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n\n      // merge deviceId -> userVideoTrackConstraints\n      let /** @type {?} */ videoTrackConstraints = WebcamComponent.getMediaConstraintsForDevice(deviceId, userVideoTrackConstraints);\n\n      navigator.mediaDevices.getUserMedia( /** @type {?} */((<MediaStreamConstraints>{video: videoTrackConstraints})))\n        .then((stream: MediaStream) => {\n          this.mediaStream = stream;\n          _video.srcObject = stream;\n          _video.play();\n\n          this.activeVideoSettings = stream.getVideoTracks()[0].getSettings();\n          let /** @type {?} */ activeDeviceId: string = WebcamComponent.getDeviceIdFromMediaStreamTrack(stream.getVideoTracks()[0]);\n          this.activeVideoInputIndex = activeDeviceId ? this.availableVideoInputs\n            .findIndex((mediaDeviceInfo: MediaDeviceInfo) => mediaDeviceInfo.deviceId === activeDeviceId) : -1;\n          this.videoInitialized = true;\n\n          this.cameraSwitched.next(activeDeviceId);\n        })\n        .catch((err: MediaStreamError) => {\n          this.initError.next( /** @type {?} */((<WebcamInitError>{message: err.message, mediaStreamError: err})));\n        });\n    } else {\n      this.initError.next( /** @type {?} */((<WebcamInitError> {message: \"Cannot read UserMedia from MediaDevices.\"})));\n    }\n  }\n/**\n * @return {?}\n */\nprivate getActiveVideoTrack(): MediaStreamTrack {\n    return this.mediaStream ? this.mediaStream.getVideoTracks()[0] : null;\n  }\n/**\n * @return {?}\n */\nprivate isMirrorImage(): boolean {\n    if (!this.getActiveVideoTrack()) {\n      return false;\n    }\n\n    // check for explicit mirror override parameter\n    {\n      let /** @type {?} */ mirror: string = \"auto\";\n      if (this.mirrorImage) {\n        if (typeof this.mirrorImage === \"string\") {\n          mirror = String(this.mirrorImage).toLowerCase();\n        } else {\n          // WebcamMirrorProperties\n          if (this.mirrorImage.x) {\n            mirror = this.mirrorImage.x.toLowerCase();\n          }\n        }\n      }\n\n      switch (mirror) {\n        case \"always\":\n          return true;\n        case \"never\":\n          return false;\n      }\n    }\n\n    // default: enable mirroring if webcam is user facing\n    return WebcamComponent.isUserFacing(this.getActiveVideoTrack());\n  }\n/**\n * Stops all active media tracks.\n * This prevents the webcam from being indicated as active,\n * even if it is no longer used by this component.\n * @return {?}\n */\nprivate stopMediaTracks() {\n    if (this.mediaStream && this.mediaStream.getTracks) {\n      // getTracks() returns all media tracks (video+audio)\n      this.mediaStream.getTracks()\n        .forEach((track: MediaStreamTrack) => track.stop());\n    }\n  }\n/**\n * Unsubscribe from all open subscriptions\n * @return {?}\n */\nprivate unsubscribeFromSubscriptions() {\n    if (this.triggerSubscription) {\n      this.triggerSubscription.unsubscribe();\n    }\n    if (this.switchCameraSubscription) {\n      this.switchCameraSubscription.unsubscribe();\n    }\n  }\n/**\n * Reads available input devices\n * @return {?}\n */\nprivate detectAvailableDevices(): Promise<MediaDeviceInfo[]> {\n    return new Promise((resolve, reject) => {\n      WebcamUtil.getAvailableVideoInputs()\n        .then((devices: MediaDeviceInfo[]) => {\n          this.availableVideoInputs = devices;\n          resolve(devices);\n        })\n        .catch(err => {\n          this.availableVideoInputs = [];\n          reject(err);\n        });\n    });\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Component, args: [{\n  selector: 'webcam',\n  template: `\n    <div class=\"webcam-wrapper\" (click)=\"imageClick.next();\">\n      <video #video [width]=\"videoWidth\" [height]=\"videoHeight\" [class]=\"videoStyleClasses\" autoplay muted playsinline></video>\n      <div class=\"camera-switch\" *ngIf=\"allowCameraSwitch && availableVideoInputs.length > 1 && videoInitialized\" (click)=\"rotateVideoInput(true)\"></div>\n      <canvas #canvas [width]=\"width\" [height]=\"height\"></canvas>\n    </div>\n  `,\n  styles: [`\n    .webcam-wrapper {\n      display: inline-block;\n      position: relative;\n      line-height: 0; }\n      .webcam-wrapper video.mirrored {\n        -webkit-transform: scale(-1, 1);\n                transform: scale(-1, 1); }\n      .webcam-wrapper canvas {\n        display: none; }\n      .webcam-wrapper .camera-switch {\n        background-color: rgba(0, 0, 0, 0.1);\n        background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAE9UlEQVR42u2aT2hdRRTGf+cRQqghSqihdBFDkRISK2KDfzDWxHaRQHEhaINKqa1gKQhd6EZLN+IidCH+Q0oWIkVRC21BQxXRitVaSbKoJSGtYGoK2tQ/tU1jY5v0c5F54Xl7b/KSO/PyEt+3e5f75p7zzZwzZ74zUEIJJfyfYaEGllQGVAGZlENdBy6Z2cSiYFTSKkkfS/pH/nBF0kFJdUW9AiRVASeAukD8DgNrzOySrwEzng18KaDzALXuG8W3AiStAvqBisBRNg40mtlPxbYCOgvgPO4bncWW+JpVeDQXRQhIygDfA00F5r0XuNfMrgclQFI98DDQCNQA5ZFXqoCWBVp8XwHRHeEqcN7loy/NbHBesyqpQ1KfFj/6nC+ZvFaApFrgPaCZpYVvgCfNbDiRAElNwGFg+RIt/X8H2s2s9wYCJDUAR4HqJX7++RN40MwGpgmQVAH0AQ2BPz4AHHPl8nBOAqtyFWQjsA6oL4Ada81sPDv7uwImod8kvSJp9RyS8O2SXnb/DYVd2Y9VSroQ4ANXJO2WVJmixqh0kzMWwL4LkiqRtDnA4D1zmfE8j9g9AezcnAHaPcfXdbfdnPZ2Yps6+DwAvO/Z1naTdApY7Xng48BDZnY1MpMVQBuw3iXc5Tnb0wBwBPjUzP6eoezuArZ6svM0geJLkvZEYnl3nkntoqROSbckSW2Suj3ZOIangc7GPJuUtNGdFIfmMeavktoSSKiW9LMPw30Q8JqkekmjCbOZRhuclLQjgYSNxUBAj6RyZ9ATgUJpUtJTCSR8vpAEXHAyWK5BXYFIGHOlepSAloUk4NEYgyoknQhEwhFJ0e8h6VSaQeerCb5uZgdi9utxYBNwOUD93hIVXswM4INCi6K9wAszFC2DwLOBDjHbYp59karIUnRdzYy/3ClqVklaUhfwTICj7K25OqA7a4wWagVsm4Me/xzwg2cCqqONFzO7DPxSCAJi436GUBgHHguQD2oTlJ55oSzP9ybccsttSJw1szdjFOSnI/8dTCGZHwcORp4Nx7y3B1iZ8/sm4MW8/Euxg5wIsS/HaAp3zeP4/G7obRDXI4jiTIA22H7Xdc7X+S3A5lC7QBQ357aq3VAjCeSkwUfAJrfvz+R8A9ADLAtZB+TinpjC5JMA+//jwPZZnF8G7J+L8z4IWB/zbG+gIujVWfLBW/NStVMmqaG4POJRsIjix7h8IGnLQuoBbQki5sVAJHyYm7YkNaRRtXwQ8G1cHpX0iKRrgUjYno17Sf0LrQhJUkdCeHWkVITGJI0k1QeS3ikGSUzOyJUJJNznYneuOCnpTldcxa2kP3xJYqOeSDjqZG8ShJLnE8TTuMS6Iyu1BW7djZqkfo9N0QOuYJmYQddfB7RG+gLTNzqAY9FrL+5/nwEbvDdJJe3zzOrhNP3AWRqmk55t3ZcBuj3b2gb0Sbrbo/NNzk7fFzu7s/E5EiC+rrmeQU0Kx2skvRFoOx2ZzlmSdgbsw49JetvtBpk8nM64d/cGbNtJ0s7cGyJlwHeEv+t3nqnLSgPAUOSGyG3AHUxdzqoJbEcvcL+ZTeTeEapzJKxgaeOcc/7Mf06D7kFrguS0VDAMtGadv+E47DT9tcChJej8ISfpD+abgTe45uOkFi8mnQ+JBVQ+d4VXuOptjavcyot8pq86mfwk8LWZnaOEEkoooYQSSojDv8AhQNeGfe0jAAAAAElFTkSuQmCC\");\n        background-repeat: no-repeat;\n        border-radius: 5px;\n        position: absolute;\n        right: 13px;\n        top: 10px;\n        height: 48px;\n        width: 48px;\n        background-size: 80%;\n        cursor: pointer;\n        background-position: center;\n        -webkit-transition: background-color 0.2s ease;\n        transition: background-color 0.2s ease; }\n        .webcam-wrapper .camera-switch:hover {\n          background-color: rgba(0, 0, 0, 0.18); }\n  `]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'width': [{ type: Input },],\n'height': [{ type: Input },],\n'videoOptions': [{ type: Input },],\n'allowCameraSwitch': [{ type: Input },],\n'mirrorImage': [{ type: Input },],\n'imageCapture': [{ type: Output },],\n'initError': [{ type: Output },],\n'imageClick': [{ type: Output },],\n'cameraSwitched': [{ type: Output },],\n'video': [{ type: ViewChild, args: ['video', ] },],\n'canvas': [{ type: ViewChild, args: ['canvas', ] },],\n'trigger': [{ type: Input },],\n'switchCamera': [{ type: Input },],\n};\n}\n\nfunction WebcamComponent_tsickle_Closure_declarations() {\n/** @type {?} */\nWebcamComponent.DEFAULT_VIDEO_OPTIONS;\n/** @type {?} */\nWebcamComponent.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nWebcamComponent.ctorParameters;\n/** @type {?} */\nWebcamComponent.propDecorators;\n/**\n * Defines the max width of the webcam area in px\n * @type {?}\n */\nWebcamComponent.prototype.width;\n/**\n * Defines the max height of the webcam area in px\n * @type {?}\n */\nWebcamComponent.prototype.height;\n/**\n * If the Observable represented by this subscription emits, an image will be captured and emitted through\n * the 'imageCapture' EventEmitter\n * @type {?}\n */\nWebcamComponent.prototype.triggerSubscription;\n/**\n * Defines base constraints to apply when requesting video track from UserMedia\n * @type {?}\n */\nWebcamComponent.prototype.videoOptions;\n/**\n * Flag to enable/disable camera switch. If enabled, a switch icon will be displayed if multiple cameras were found\n * @type {?}\n */\nWebcamComponent.prototype.allowCameraSwitch;\n/**\n * Parameter to control image mirroring (i.e. for user-facing camera). [\"auto\", \"always\", \"never\"]\n * @type {?}\n */\nWebcamComponent.prototype.mirrorImage;\n/**\n * Subscription to switchCamera events\n * @type {?}\n */\nWebcamComponent.prototype.switchCameraSubscription;\n/**\n * MediaStream object in use for streaming UserMedia data\n * @type {?}\n */\nWebcamComponent.prototype.mediaStream;\n/**\n * available video devices\n * @type {?}\n */\nWebcamComponent.prototype.availableVideoInputs;\n/**\n * Index of active video in availableVideoInputs\n * @type {?}\n */\nWebcamComponent.prototype.activeVideoInputIndex;\n/**\n * Indicates whether the video device is ready to be switched\n * @type {?}\n */\nWebcamComponent.prototype.videoInitialized;\n/**\n * EventEmitter which fires when an image has been captured\n * @type {?}\n */\nWebcamComponent.prototype.imageCapture;\n/**\n * Emits a mediaError if webcam cannot be initialized (e.g. missing user permissions)\n * @type {?}\n */\nWebcamComponent.prototype.initError;\n/**\n * Emits when the webcam video was clicked\n * @type {?}\n */\nWebcamComponent.prototype.imageClick;\n/**\n * Emits the active deviceId after the active video device was switched\n * @type {?}\n */\nWebcamComponent.prototype.cameraSwitched;\n/** @type {?} */\nWebcamComponent.prototype.video;\n/** @type {?} */\nWebcamComponent.prototype.canvas;\n/** @type {?} */\nWebcamComponent.prototype.activeVideoSettings;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {NgModule} from '@angular/core';\nimport {CommonModule} from '@angular/common';\nimport {WebcamComponent} from './webcam/webcam.component';\n\nconst /** @type {?} */ COMPONENTS = [\n  WebcamComponent\n];\nexport class WebcamModule {\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  imports: [\n    CommonModule\n  ],\n  declarations: [\n    COMPONENTS\n  ],\n  exports: [\n    COMPONENTS\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction WebcamModule_tsickle_Closure_declarations() {\n/** @type {?} */\nWebcamModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nWebcamModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\nexport class WebcamInitError {\npublic message: string = null;\npublic mediaStreamError: MediaStreamError = null;\n}\n\nfunction WebcamInitError_tsickle_Closure_declarations() {\n/** @type {?} */\nWebcamInitError.prototype.message;\n/** @type {?} */\nWebcamInitError.prototype.mediaStreamError;\n}\n\n","\nexport class WebcamMirrorProperties {\npublic x: string;  // [\"auto\", \"always\", \"never\"]\n}\n\nfunction WebcamMirrorProperties_tsickle_Closure_declarations() {\n/** @type {?} */\nWebcamMirrorProperties.prototype.x;\n}\n\n"],"names":["WebcamImage","imageAsDataUrl","mimeType","this","_mimeType","_imageAsBase64","_imageAsDataUrl","Object","defineProperty","prototype","get","getDataFromDataUrl","dataUrl","replace","WebcamUtil","getAvailableVideoInputs","navigator","mediaDevices","enumerateDevices","Promise","resolve","reject","then","devices","filter","device","kind","catch","err","message","WebcamComponent","width","height","videoOptions","DEFAULT_VIDEO_OPTIONS","allowCameraSwitch","mediaStream","availableVideoInputs","activeVideoInputIndex","videoInitialized","imageCapture","EventEmitter","initError","imageClick","cameraSwitched","activeVideoSettings","ngAfterViewInit","_this","detectAvailableDevices","switchToVideoInput","length","deviceId","next","ngOnDestroy","stopMediaTracks","unsubscribeFromSubscriptions","set","trigger","triggerSubscription","unsubscribe","subscribe","takeSnapshot","switchCamera","switchCameraSubscription","value","rotateVideoInput","getMediaConstraintsForDevice","baseMediaTrackConstraints","result","exact","getDeviceIdFromMediaStreamTrack","mediaStreamTrack","getSettings","getConstraints","deviceIdObj","getValueFromConstrainDOMString","getFacingModeFromMediaStreamTrack","facingMode","facingModeConstraint","isUserFacing","toLowerCase","constrainDOMString","String","Array","isArray","_video","video","nativeElement","dimensions","videoWidth","videoHeight","_canvas","canvas","getContext","drawImage","toDataURL","forward","increment","initWebcam","videoRatio","getVideoAspectRatio","Math","min","classes","isMirrorImage","trim","mediaTrackSettings","aspectRatio","userVideoTrackConstraints","getUserMedia","videoTrackConstraints","stream","srcObject","play","getVideoTracks","activeDeviceId","findIndex","mediaDeviceInfo","mediaStreamError","getActiveVideoTrack","mirror","mirrorImage","x","getTracks","forEach","track","stop","decorators","type","Component","args","selector","template","styles","ctorParameters","propDecorators","Input","Output","ViewChild","COMPONENTS","WebcamModule","NgModule","imports","CommonModule","declarations","exports","WebcamInitError","WebcamMirrorProperties"],"mappings":"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"}
